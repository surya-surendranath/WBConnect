'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _lodash = require('lodash');

var _promise = require('../promise');

var _promise2 = _interopRequireDefault(_promise);

var BatchInsert = (function () {
  function BatchInsert(client, tableName, batch) {
    var chunkSize = arguments.length <= 3 || arguments[3] === undefined ? 1000 : arguments[3];

    _classCallCheck(this, BatchInsert);

    if (!(0, _lodash.isNumber)(chunkSize) || chunkSize < 1) {
      throw new TypeError('Invalid chunkSize: ' + chunkSize);
    }

    if (!(0, _lodash.isArray)(batch)) {
      throw new TypeError('Invalid batch: Expected array, got ' + typeof batch);
    }

    this.client = client;
    this.tableName = tableName;
    this.batch = (0, _lodash.chunk)(batch, chunkSize);
    this._returning = void 0;
    this._transaction = null;
    this._autoTransaction = true;
  }

  /**
   * Columns to return from the batch operation.
   * @param returning
   */

  _createClass(BatchInsert, [{
    key: 'returning',
    value: function returning(_returning) {
      if ((0, _lodash.isArray)(_returning) || (0, _lodash.isString)(_returning)) {
        this._returning = _returning;
      }
      return this;
    }

    /**
     * User may supply their own transaction.
     * If this is the case, autoTransaction = false, meaning we don't automatically commit/rollback the transaction. The responsibility instead falls on the user.
     * @param transaction
     */
  }, {
    key: 'transacting',
    value: function transacting(transaction) {
      this._transaction = transaction;
      this._autoTransaction = false;
      return this;
    }
  }, {
    key: '_getTransaction',
    value: function _getTransaction() {
      var _this = this;

      return new _promise2['default'](function (resolve) {
        if (_this._transaction) {
          return resolve(_this._transaction);
        }
        _this.client.transaction(function (tr) {
          return resolve(tr);
        });
      });
    }
  }, {
    key: 'then',
    value: function then() {
      var _this2 = this;

      var callback = arguments.length <= 0 || arguments[0] === undefined ? function () {} : arguments[0];

      return this._getTransaction().then(function (transaction) {
        return _promise2['default'].all(_this2.batch.map(function (items) {
          return transaction(_this2.tableName).insert(items, _this2._returning);
        })).then(function (result) {
          if (_this2._autoTransaction) {
            transaction.commit();
          }
          return callback((0, _lodash.flatten)(result || []));
        })['catch'](function (error) {
          if (_this2._autoTransaction) {
            transaction.rollback(error);
          }
          throw error;
        });
      });
    }
  }]);

  return BatchInsert;
})();

exports['default'] = BatchInsert;
module.exports = exports['default'];